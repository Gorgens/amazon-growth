---
title: "Material e Métodos"
output: html_document
---

```{r pacotes2, echo=FALSE, warning=FALSE}
require(tidyverse)
require(magrittr)
require(reshape2)
require(ggplot2)
require(phytools)
require(knitr)
```

Este estudo incluiu 28 inventários contínuos distribuidos nos estados do Pará, Amazonas, Acre, Rondônia e Mato Grosso. No total, foram analisadas 355 parcelas contendo 41580 indíviduos. Os dados fazem parte do projeto Paisagens Sustentáveis Brasil e estão disponíveis para download na plataforma do projeto  (https://www.embrapa.br/en/busca-de-solucoes-tecnologicas/-/produto-servico/3862/paisagens-sustentaveis). Após descartadar todas as árvores com diâmetros menores que 10 cm, e também as palmeiras, restaram 36283 árvores. 

```{r limparInventario, echo=FALSE, warning=FALSE}
invMerged = read.csv("dados/10_invPaisagensMerged.csv")
nParcelasAntes= length(unique(paste(invMerged$area, invMerged$plot)))
invMerged = invMerged %>%
  filter(type == "O" | is.na(type)) %>%
  drop_na(DBH) %>%
  filter(DBH >= 10) 
  

 nParcelasDepois= length(unique(paste(invMerged$area, invMerged$plot)))

```

```{r numeroParcelas, echo=FALSE, warning=FALSE}
parcelasArea = invMerged %>%
  group_by(area, plot, subplot, year) %>%
  summarise(obs = n()) %>%
  group_by(area, year) %>%
  summarise(nplots = n())
 
```

O incremento diamétrico anual ($d_{growth}$) foi determinado pela da divisão do incremento diamétrico observado entre o diâmetro da primeira e da segunda medição, pelo período em anos entre as medições.


$$d_{growth} = \frac{d_f - d_i}{t_f - t_i}$$
$d_{growth}$ é o incremento diamétrico anual, $d_f$ é o diâmetro a 1,30m obtido no último ano de medição, $d_i$ é o diâmetro a 1,30 m obtido no primeiro ano de medição, $t_f$ é a data da última medição e $t_i$ é a data da primeira medição. 


O incremento diamétrico relativo ($d_{rGrowth}$) pôde ser calculado dividindo o incremento diamétrico anual pelo diâmetro a 1,30 obtido na primeira medição:

$$d_{rGrowth} = \frac{d_{growth}}{d_i}$$

Em que $d_{rGrowth}$ é o incremento diamétrico relativo, $d_{growth}$ é o incremento diamétrico anual e $d_i$ é o diâmetro a 1,30 m obtido na primeira medição.

As espécies foram agrupadas com base nos grupos ecológicos propostos por @Macpherson2007. As espécies cujo grupo ecológico foram indeterminar, foram excluídas da comparação. Os grupos foram comparados quanto ao incremento diamétrico relativo e quanto à distribuição diamétrica. A comparação entre grupos foi feita utilizando a estatística bayesiana implementada no pacote *rstanarm* e *bayesplot*, ambos para linguagem R de programação.

O modelo linear generalizado da função gama, com ligação logarítmica, foi usado para comparar o efeito dos grupos ecológicos no incremento relativo. Para analisar o efeito dos grupos eológicos na distribuição diamétrica, foi utilizado o modelo de Meyer linearizado, com a função de ligação identidade.  The statistical analysis performed a Bayesian estimation via MCMC of the generalized linear models. The Bayesian model adds priors on the coefficients of the GLM, and compute the posterior values based on observed data [@muth2018].

O modelo de Meyer é definido como:

$$N_j = e^{\beta_0 + \beta_1 D_j}$$

em que $N_j$ indica o número de indivíduos na classe de diâmetro $j$ e $D_j$ indica o centro da classe $j$. E pode ser generalizado por meio da transformação logaritmica da variáveis dependente:

$$log(N_j) = \beta_0 + \beta_1 D_j$$

```{r gruposEcologicos, echo=FALSE, warning=FALSE}
grupoEco = read.csv('auxiliar/grupoEcologico.csv')
eco = grupoEco %>% group_by(GrupoEco) %>% summarise(Species = n())
```

```{r pareamentoIncremento, echo=FALSE, warning=FALSE}
incEco = invMerged %>%
  drop_na(GrupoEco) %>%
  filter(GrupoEco != "Others") %>%
  group_by(area, plot, subplot, tree, scientific.name, GrupoEco) %>%
  summarise(med = n(),
            cc = min(cc), 
            minDBH = min(DBH), 
            maxDBH = max(DBH), 
            inc = max(DBH) - min(DBH), 
            intervMed = max(year) - min(year), 
            incAnual = ifelse(inc == 0, 0.01, inc / intervMed),
            rInc = incAnual / minDBH) %>%
  filter(med > 1)
  
```






